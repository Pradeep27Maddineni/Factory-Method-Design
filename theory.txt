The Factory Method pattern is a creational design pattern that provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created. It encapsulates the object creation logic, decoupling it from the client code that uses the objects.
It provides an interface(method to create object) but exact actual responsibility of object instantiation is of subclasses.
Always code to an interface but not to an implementation.

When to Use Factory Method Design Pattern?
The Factory Method pattern is best suited for scenarios where:
    The exact class of objects to be created is not known at compile time.
    The client code needs to be decoupled from the concrete classes of objects it creates.
    There’s a need for flexibility in object creation, allowing subclasses to provide variations of the created objects.

Components of Factory Method Design Pattern:
    Product: Represents the interface of the objects created by the factory method.
    ConcreteProduct: Implements the Product interface and represents the concrete objects created by the factory method.
    Creator: Declares the factory method, which returns an instance of the Product interface.
    ConcreteCreator: Implements the factory method to create instances of ConcreteProduct.

Example:

#include <iostream>
#include <memory>
using namespace std;

// Product interface
class Pizza {
public:
    virtual void prepare() = 0;
    virtual void bake() = 0;
    virtual void cut() = 0;
    virtual void box() = 0;
    virtual ~Pizza() = default;
};

// ConcreteProduct implementations
class MargheritaPizza : public Pizza {
public:
    void prepare() override {
        cout << "Preparing Margherita Pizza..." << endl;
    }
    void bake() override {
        cout << "Baking Margherita Pizza..." << endl;
    }
    void cut() override {
        cout << "Cutting Margherita Pizza..." << endl;
    }
    void box() override {
        cout << "Boxing Margherita Pizza..." << endl;
    }
};

class PepperoniPizza : public Pizza {
public:
    void prepare() override {
        cout << "Preparing Pepperoni Pizza..." << endl;
    }
    void bake() override {
        cout << "Baking Pepperoni Pizza..." << endl;
    }
    void cut() override {
        cout << "Cutting Pepperoni Pizza..." << endl;
    }
    void box() override {
        cout << "Boxing Pepperoni Pizza..." << endl;
    }
};

// Creator interface
class PizzaFactory {
public:
    virtual unique_ptr<Pizza> createPizza() = 0;
    virtual ~PizzaFactory() = default;
};

// ConcreteCreator implementations
class MargheritaPizzaFactory : public PizzaFactory {
public:
    unique_ptr<Pizza> createPizza() override {
        return make_unique<MargheritaPizza>();
    }
};

class PepperoniPizzaFactory : public PizzaFactory {
public:
    unique_ptr<Pizza> createPizza() override {
        return make_unique<PepperoniPizza>();
    }
};

// Client code
int main() {
    unique_ptr<PizzaFactory> pizzaFactory = make_unique<MargheritaPizzaFactory>();
    unique_ptr<Pizza> pizza = pizzaFactory->createPizza();

    pizza->prepare();
    pizza->bake();
    pizza->cut();
    pizza->box();

    return 0;
}

Pizza → Abstract Product (interface in Java, pure virtual class in C++)
MargheritaPizza, PepperoniPizza → Concrete Products
PizzaFactory → Abstract Creator
MargheritaPizzaFactory, PepperoniPizzaFactory → Concrete Creators
main() → Client code that requests a pizza through the factory

Encourages loose coupling between client code and the created objects.
Provides a centralized point of control for object creation, facilitating easier maintenance and testing.
Supports the Open/Closed Principle, allowing for the addition of new product types without modifying existing client code.
Promotes code reusability by defining common creation logic in superclass methods.

The Factory Method Design Pattern is a powerful tool for creating objects in a flexible, decoupled, and extensible manner. By encapsulating object creation logic in subclasses, the Factory Method pattern promotes code reusability, maintainability, and scalability. While it may introduce some complexity, especially in large codebases, its benefits outweigh the drawbacks, making it a valuable addition to any developer’s toolkit.

Example:

#include <iostream>
#include <string>
#include <memory> // For smart pointers
using namespace std;

// Abstract base class (Interface)
class Notification {
public:
    virtual void send(const string& message) = 0; // Pure virtual function
    virtual ~Notification() {} // Virtual destructor
};

// Concrete Products
class EmailNotification : public Notification {
public:
    void send(const string& message) override {
        cout << "Email: " << message << endl;
    }
};

class SMSNotification : public Notification {
public:
    void send(const string& message) override {
        cout << "SMS: " << message << endl;
    }
};

class PushNotification : public Notification {
public:
    void send(const string& message) override {
        cout << "Push notification: " << message << endl;
    }
};

// Simple Factory
class SimpleNotificationFactory {
public:
    static unique_ptr<Notification> createNotification(const string& type) {
        if (type == "EMAIL") {
            return make_unique<EmailNotification>();
        } else if (type == "SMS") {
            return make_unique<SMSNotification>();
        } else if (type == "PUSH") {
            return make_unique<PushNotification>();
        } else {
            throw runtime_error(type + " not supported yet.");
        }
    }
};

// Usage
int main() {
    try {
        auto emailSender = SimpleNotificationFactory::createNotification("EMAIL");
        emailSender->send("Hello via Email!");

        auto smsSender = SimpleNotificationFactory::createNotification("SMS");
        smsSender->send("Hello via SMS!");

        auto pushSender = SimpleNotificationFactory::createNotification("PUSH");
        pushSender->send("Hello via Push Notification!");
    }
    catch (const exception& e) {
        cerr << "Error: " << e.what() << endl;
    }

    return 0;
}
